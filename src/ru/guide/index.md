# Документация

[[toc]]
---

::: tip Предыстория
Next2 является переработкой более ранней библиотеки [psr15-next](https://github.com/alexpts/psr15-next/).
Первая версия была написана для простой, гибкой и быстрой работы
с [PSR-15 middleware](https://www.php-fig.org/psr/psr-15/) в стиле приложений на фреймворке [KoaJs](https://koajs.com/),
который в свою очередь очень похож на [ExpressJs](https://expressjs.com/).
:::

## Hello World

Минимальное приложение с поддержкой PSR-7 на **Next2** выглядит так:

@[code{4-} php{12-16}](../../example/hello-world.php)

## Глоссарий

#### Приложение

Приложение является самым высоким уровнем и реалзиует полноую обработку запроса.
Задача приложения получить на входе http request и создать http response.

#### Middleware (обработчик промежуточного уровня)

Часть приложения, которая отчечает за конкретную единицу логики в обработке
request/response. ([PSR-15 middleware](https://www.php-fig.org/psr/psr-15/))

::: tip Отсылка к PSR-15
Первой версия фреймворка использовала [PSR-15 middleware](https://www.php-fig.org/psr/psr-15/).
Next2 используеют похожую на `PSR-15` по смыслу и сигнатуре модель выстраивания обработчиков.

Отличия от PSR-15 обработчиков:

- Обработчиком промежуточного уровня выступает любой обработчик с типом `callable`
  вместо `Psr\Http\Server\MiddlewareInterface`.
- Layer может запускать не 1 обработчик, а группу обработчиков `callable[]`, позволяя делить код на более мелкие части
  сохраняя логическую целостность.
  :::

#### Layer / Слой

Это абстракция над middleware обработчиком, которая содержит метаинформцию (для простоты это можно считатать алиасом
middleware). Приложение это набор Layers, которые определяются для каждого http запроса.

---

Приложение осознано сводит число сущностей к минимуму, чтобы оставаться действительно простым, понятным и надежным.
Основное понятие с которым придется постоянно работать это Layer (Слой). Layer это абсстракция над обработчиком, котоырй
может быть представлен любым способом и соответсвует типу `callable` в PHP.

Приложеине получает на вход стандартный объект запроса `PSR-7` и прогоняет через все обработчики слоев. Какие именно
слои примут частие в обработке запроса определяется метаифнормацией слоя. Семантически можно выделить следующие типы
слоев:

- Активация на любом запросе
- Активация по http методу
- Активация по соответствию uri в регулярном выражении

::: details Собственные стратегии
Из коробки идет минимальный набор стратений (по http методу и поиск по uri). Можно дополнительно реализовать любые
кастомные правила, по которым будет принято решеине активируетя слой для обработки request или нет. Для э того нужно
добавить свою реализацию `PTS\Next2\Layer\Resolver\LayerResolverInterface`
:::

## Слои

Приложение `MicroApp` хранит в себе в свойстве `$app->store` хранилище слоев `LayersStore`.
Хранилище слоев позволяет добавлять обрабочтики к приложению посредством метода `use`:

```php
    /**
     * @param callable[] | callable $handler
     */
    public function use(callable|array $handler, array $options = []): static
    {
        $layer = $this->layerFactory->create($handler, $options);
        return $this->addLayer($layer);
    }
```

### Handler

Обработчиком может выступать любая форма `callable` PHP типа. Функция обработчик в общем случае принмает 2 аргумента.
Первый аргумент это контекст, который должнен реализовывать `PTS\Next2\Context\ContextInterface` либо его наследников в
случае расширения базового контекста под себя.

::: tip Context
Контекст - это связующая часть между всеми слоями. Базовый контекст хранит request, response и позволяет получить доступ
к текущему слою (Layer) в runtime. В контексте можно хранить все что угодно, расширяя его дочерним классом и не
ограничивая себя. Данный подход хорошо себя зарекомендовал в таких фреймворках как [koaJs](https://koajs.com/)
и [goFiber](https://gofiber.io/).
:::

Второй аргкмент является функция `callable $next`, которую нужно вызывать, если требуется передать управление следующему
слою.

::: tip Middleware подход
Каждый слой имеет 1 определенную зону отвественности, это позволяет оставаться вашему коду простым и чистым.
Слой может самостоятельно создать http response и не передавать управление следующему слою. Например слой, который
проверяет аунтификацию, может сам создать http response с статус кодом `401` с текстом ошибки, что требуется
аунтификация. С таким подходом, мы можем очень быстро обрабатывать некоторые запросы, даже не поднимая тяжелый фреймвор,
если он используется на последующих слоях.

Другой пример, это обработчик, который может кешировать запрос и повторно очень быстро отвечать на запрос из кеша.
:::

### Options

| Опция            | Описание                                                                                                                                                                 | По умолчанию | Пример значения  |
|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------|------------------|
| **path**         | описывает uri путь, на который должен активироваться слой, можро использловать регулярки, без указария этого параметра слой активируется на любой uri                    | -            | `/users/{id}`    |
| **name**         | определяем уникальное имя слоя, через это имя можно будет найти слой (по умолчанию все слои получают имена вида `l-0`, `l-1` и т.д.)                                     | -            | `usersAction`    |
| **methods**      | принимает массив из http методов, слой активируется только на http запросы с указанными http методами. Если методы не переданы, то слой активируется на любой http метод | `[]`         | `['GET']`        |
| **priority**     | принимает `int` число с приоритетом, чем ни меньше число, тем раньше выполнится слой. Это позволяет конфигурировать слои декларативно, не в порядке добавления           | `50`         | `100`            |
| **restrictions** | принимает массив вида ['id' => \id+], позволяя накладывать дополнительные ограничения на переменны в uri запроса                                                         | `[]`         | `['id'=>'\id+']` |
| **contenxt**     | позволяет прикрепить к слою любые произволные данные                                                                                                                     | `[]`         | `['foo'=>'bar']` |

Пример использования options в коде:
@[code{4-} php{18-25}](../../example/layer-options.php)

### Быстрые http методы (сахар)

Для упрощения также доступны методы, которые зеркалируют основные http методы, например:

```php
$app->store->get('/users/{id}/', fn($ctx) => $ctx->response = new JsonResponse);
$app->store->post('/users/{id}/', fn($ctx) => ...);
$app->store->patch('/users/{id}/', fn($ctx) => ...);
$app->store->put('/users/{id}/', fn($ctx) => ...);
$app->store->delete('/users/{id}/', fn($ctx) => ...);
```

::: tip Быстрые методы
Полный список методов можно найти в трейте `PTS\Next2\Layer\Store\FastMethodsTrait`. Он реализует самые популярные
методы. Вы можете добавить свои методы для сахара
:::

### Декларативная кофнигурация

Очень удобно конфигурировать маргруты и порядо декларативно, например посредством yml файлов, простой пример такой
конфигурации выглядит так:

```yml
# middlewares
ThrowableToResponse:
  controller: Site\Middleware\ThrowableToResponse:process

# 404 page
otherwise:
  handler: Site\Controller\Action\Page404:__invoke
  name: otherwise
  priority: 10000

# actions
main:
  path: /
  methods: [ 'GET' ]
  handler: Site\Controller\OtherwiseController:mainPage

posts:
  path: /post/
  methods: [ 'GET' ]
  handler: Site\Controller\PostController:getList

cat:
  path: /cat/{id}/
  restrictions:
    id: ""\d+"
  methods: [ 'GET' ]
  handler: Site\Controller\CategoryController:getCat
```

### Flow

Каждый слой может что-то делать до вызова `$next()` на этапе запроса, также может что-то делать после вызова `$next()`
на этапе ответа. Пример полного выполнения запроса, который проходит сквозь все слои:

![200 flow](/img/layers/200.png?style=centerme)

Пример flow, кога запрос досрочно может быть обработан одним из слоев, без вызова `$next()`:

![401 flow](/img/layers/401.png?style=centerme)

<!--
```yml
@startuml
scale 1.3
title: 401 response

Client -> App: http request
    activate App
    App -> "Auth Layer": request
    
        activate "Auth Layer"
        "Auth Layer" -> App: 401 response
        deactivate "Auth Layer"
    
    App -> Client: http response
    deactivate App
@enduml
```
-->

Каждый слоq решает сам, создать http response и пректатить обработку, либо вызвать следующий слой и делегировать ему
обработку.

## PSR-15 Middleware

### Интеграция
Приложение реализует интерфейс `Psr\Http\Server\RequestHandlerInterface` из `PSR-15`. За счет этого оно может
интегрировться в любое приложение как middleware, принимая на вход `PSR7 Request` и возвращая `PSR7 Response`.

Схематично это выглядит как `psr15` -> `psr15` -> `next2`. 

---

Если микро приложение должно дерегировать обработку запроса далее в классическую `PSR-15 Middleware`, то можно обернуть в такую middleware:

@[code{4-}](../../example/psr15-middelware.php)

Схематично это выглядит как `psr15` -> `psr15` -> `next2` -> `psr15`.

Такие интеграции позволяют точечно заменять части старого приложения или переносить небольшими кусочками часть функционала.


## TODO

- подумать о передачи в `$next()` аргументов, которые придут 3+ аргументами в следующий handler. (Посмотреть примеры в
  koa)
- подумать об ограничении параметров до регулядки [A-Za-z0-9_-])
- подумать о автозаполнителях и валидаторах параметров из запроса как в koaJs
  router [param](https://github.com/ZijianHe/koa-router#module_koa-router--Router+param)

